<?php

declare(strict_types=1);

namespace Manychois\Simdom\Internal\Parsing;

use Manychois\Simdom\Internal\StringStream;

/**
 * Provides methods for tokenizing start and end tags in the lexer.
 */
class LexerTagLogic
{
    private readonly TokenEmitter $emitter;
    private readonly StringStream $str;

    /**
     * Constructor.
     *
     * @param StringStream $str     The string stream to be tokenized.
     * @param TokenEmitter $emitter The token emitter to receive the tokens.
     */
    public function __construct(StringStream $str, TokenEmitter $emitter)
    {
        $this->str = $str;
        $this->emitter = $emitter;
    }

    /**
     * Tokenizes all the attributes into the current tag.
     *
     * @param StartTagToken|EndTagToken $token The token to be populated with the attributes.
     */
    public function tokenizeAllAttrs(StartTagToken|EndTagToken $token): void
    {
        while ($this->tokenizeAttr($token));
    }

    /**
     * Tokenizes in the end tag open state.
     *
     * @return bool True if the tokenization is successful.
     */
    public function tokenizeEndTagOpen(): bool
    {
        $chr = $this->str->current();
        if ($chr >= 'a' && $chr <= 'z' || $chr >= 'A' && $chr <= 'Z') {
            $tagName = $this->tokenizeTagName();
            $token = new EndTagToken($tagName);
            $this->tokenizeAllAttrs($token);
            $chr = $this->str->current();
            if ($chr === '/') {
                $this->str->advance(2); // consume "/>"
                $this->emitter->emit($token);
            } elseif ($chr === '>') {
                $this->str->advance();
                $this->emitter->emit($token);
            } else {
                $this->emitter->emit(new EofToken());
            }
        } elseif ($chr === '>') {
            $this->str->advance();
        } elseif ($chr === '') {
            $this->emitter->emit(new TextToken('</'));
            $this->emitter->emit(new EofToken());
        } else {
            return false;
        }

        return true;
    }

    /**
     * Tokenizes in the start tag state.
     */
    public function tokenizeStartTag(): void
    {
        $tagName = $this->tokenizeTagName();
        $token = new StartTagToken($tagName);
        $this->tokenizeAllAttrs($token);
        $chr = $this->str->current();
        if ($chr === '/') {
            $this->str->advance(2); // consume "/>"
            $token->selfClosing = true;
            $this->emitter->emit($token);
        } elseif ($chr === '>') {
            $this->str->advance();
            $this->emitter->emit($token);
        } else {
            $this->emitter->emit(new EofToken());
        }
    }

    /**
     * Moves the current position to the next attribute name.
     *
     * @return bool True if there is attribute name to be tokenized.
     */
    private function moveToAttrName(): bool
    {
        $chr = $this->str->current();
        if (ctype_space($chr)) {
            $this->str->advance();

            return true;
        }

        if ($chr === '' || $chr === '>') {
            return false;
        }

        if ($chr === '/') {
            $peek = $this->str->peek(2);
            if ($peek === '/>') {
                return false;
            }

            $this->str->advance();

            return true;
        }

        return true;
    }

    /**
     * Tokenizes in attribute name and value states.
     *
     * @param StartTagToken|EndTagToken $token The token to be populated with the attribute.
     *
     * @return bool True if there are more attributes to be tokenized.
     */
    private function tokenizeAttr(StartTagToken|EndTagToken $token): bool
    {
        if (!$this->moveToAttrName()) {
            return false;
        }

        $name = $this->tokenizeAttrName();
        // capture optional "=" which sits between the attribute name and value
        $matchResult = $this->str->regexMatch('/\s*(\=?)\s*/');
        $this->str->advance(strlen($matchResult->value));
        $value = $matchResult->captures[0] === '=' ? $this->tokenizeAttrValue() : null;

        if ($name !== '' && $token instanceof StartTagToken) {
            if (!$token->node->hasAttribute($name)) {
                $token->node->setAttribute($name, $value);
            }
        }

        return true;
    }

    /**
     * Tokenizes in the attribute name state.
     *
     * @return string The attribute name generated by the tokenization.
     */
    private function tokenizeAttrName(): string
    {
        $chr = $this->str->current();
        $name = '';
        if ($chr === '=') {
            $this->str->advance();
            $name = '=';
        }
        $matchResult = $this->str->regexMatch('/[^\s\/>=]*/');
        $this->str->advance(strlen($matchResult->value));
        $name .= strtolower(LexerLiteralUtility::fixNull($matchResult->value));

        return $name;
    }

    /**
     * Tokenizes in the attribute value state.
     *
     * @return string The attribute value generated by the tokenization.
     */
    private function tokenizeAttrValue(): string
    {
        $chr = $this->str->current();
        if ($chr === '"') {
            $matchResult = $this->str->regexMatch('/"([^"]*)"?\s*/s');
        } elseif ($chr === "'") {
            $matchResult = $this->str->regexMatch('/\'([^\']*)\'?\s*/s');
        } else { // unquoted version
            $matchResult = $this->str->regexMatch('/([^\s>]*)\s*/');
        }
        assert($matchResult->success);
        $this->str->advance(strlen($matchResult->value));

        return LexerLiteralUtility::decodeHtml(LexerLiteralUtility::fixNull($matchResult->captures[0]));
    }

    /**
     * Tokenizes in the tag name state.
     * The first character should have been verified to be a letter.
     *
     * @return string The tag name generated by the tokenization.
     */
    private function tokenizeTagName(): string
    {
        $matchResult = $this->str->regexMatch('/[^\s\/>]+/');
        assert($matchResult->success);
        $tagName = strtolower(LexerLiteralUtility::fixNull($matchResult->value));
        $this->str->advance(strlen($matchResult->value));

        return $tagName;
    }
}
